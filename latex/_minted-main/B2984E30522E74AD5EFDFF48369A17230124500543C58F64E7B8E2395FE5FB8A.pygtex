\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{linalg} \PYG{k}{as} \PYG{n}{la}

\PYG{k}{def} \PYG{n+nf}{ica\PYGZus{}def}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{comp}\PYG{p}{,}\PYG{n}{max\PYGZus{}it}\PYG{p}{,}\PYG{n}{tol}\PYG{p}{,}\PYG{n}{g}\PYG{p}{,}\PYG{n}{gdot}\PYG{p}{,}\PYG{n}{w\PYGZus{}init}\PYG{p}{,}\PYG{n}{alpha}\PYG{p}{):} 
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    PARAMETERS:}
\PYG{l+s+sd}{    X(array p,n): \PYGZdq{}white\PYGZdq{} array of signals that we need to estimate}
\PYG{l+s+sd}{    comp(int): independent components that we need to estimate}
\PYG{l+s+sd}{    max\PYGZus{}it(int): maximum iterations of algorithm running}
\PYG{l+s+sd}{    tol(float): tolerance error that the algorithm converge}
\PYG{l+s+sd}{    g(function): contrast function that we define on fast\PYGZus{}ica function}
\PYG{l+s+sd}{    gdot(function): contrast function that we define on fast\PYGZus{}ica function}
\PYG{l+s+sd}{    w\PYGZus{}init(array p,p): initial weights array}
\PYG{l+s+sd}{    alpha(float): parameter for g and gdot}
\PYG{l+s+sd}{    OUTPUTS:}
\PYG{l+s+sd}{    W(array p,p): estimated un\PYGZhy{}mixing matrix}

\PYG{l+s+sd}{    NOTES:}
\PYG{l+s+sd}{    We use deflational orthogonalization based on Gram\PYGZhy{}Schidt method }
\PYG{l+s+sd}{    for un\PYGZhy{}mixing matrix}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c+c1}{\PYGZsh{} prelocate un\PYGZhy{}mixing matrix }
    \PYG{n}{W} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{((}\PYG{n}{comp}\PYG{p}{,}\PYG{n}{comp}\PYG{p}{)} \PYG{p}{,} \PYG{n}{dtype} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}
    \PYG{n}{p}\PYG{p}{,}\PYG{n}{n} \PYG{o}{=} \PYG{n}{X}\PYG{o}{.}\PYG{n}{shape}
    \PYG{c+c1}{\PYGZsh{} We choose comp indepented components to estimate}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{comp}\PYG{p}{):}
        \PYG{c+c1}{\PYGZsh{} Choose an initial value and normalize it }
        \PYG{n}{w} \PYG{o}{=} \PYG{n}{w\PYGZus{}init}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,:]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{()}
        \PYG{n}{w} \PYG{o}{/=} \PYG{n}{la}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} 
        
        \PYG{n}{iterations} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{;} \PYG{n}{lim} \PYG{o}{=} \PYG{l+m+mf}{1.01}
        \PYG{c+c1}{\PYGZsh{} we set lim = 1.01 to be sure that the algorithm will run at least one time}
        \PYG{k}{while}\PYG{p}{(} \PYG{p}{(}\PYG{n}{iterations} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}it} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{)} \PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{lim} \PYG{o}{\PYGZgt{}} \PYG{n}{tol}\PYG{p}{)} \PYG{p}{):}
            \PYG{c+c1}{\PYGZsh{} Calculate w*X product in order to calculate g(w*X) and g\PYGZsq{}(w*X)}
            \PYG{n}{wtx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{X}\PYG{p}{)[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{newaxis}\PYG{p}{,:]} \PYG{c+c1}{\PYGZsh{} shape 1xn}
            \PYG{n}{gwtx} \PYG{o}{=} \PYG{n}{g}\PYG{p}{(}\PYG{n}{wtx}\PYG{p}{,}\PYG{n}{alpha}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} shape 1xn}
            \PYG{n}{gdotwtx} \PYG{o}{=} \PYG{n}{gdot}\PYG{p}{(}\PYG{n}{wtx}\PYG{p}{,}\PYG{n}{alpha}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} shape 1xn}
            \PYG{c+c1}{\PYGZsh{} the first term of w1 computes the mean value for all the rows of X*g(wX).T (vector)}
            \PYG{c+c1}{\PYGZsh{} and the second term computes the mean value of g\PYGZsq{}(w*X) matrix (number)}
            \PYG{n}{w1} \PYG{o}{=} \PYG{p}{(}\PYG{n}{X}\PYG{n+nd}{@gwtx.T}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{gdotwtx}\PYG{p}{))}\PYG{o}{*}\PYG{n}{w} \PYG{c+c1}{\PYGZsh{} shape 1xp}
            \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{            Gram \PYGZhy{} Schmidt method:}
\PYG{l+s+sd}{            After with estimate wp vectors , we do the one unit algorithm for wp+1}
\PYG{l+s+sd}{            and after every iteration step we substract from wp+1 the projections }
\PYG{l+s+sd}{            (wp+1*wj)wj j=1, ..,p of the previously estimated vectors}
\PYG{l+s+sd}{            and then we normalize the wp+1}
\PYG{l+s+sd}{            \PYGZsq{}\PYGZsq{}\PYGZsq{}}
            \PYG{n}{temp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{)}
            \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{p}{):}
                \PYG{n}{wt} \PYG{o}{=} \PYG{n}{W}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,:]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{()}
                \PYG{c+c1}{\PYGZsh{} Calculate sum\PYGZob{}(w1*w)w\PYGZcb{}}
                \PYG{n}{temp}\PYG{o}{+=} \PYG{p}{(}\PYG{n}{w1}\PYG{n+nd}{@wt}\PYG{p}{)}\PYG{o}{*}\PYG{n}{wt}
            \PYG{n}{w1}\PYG{o}{\PYGZhy{}=}\PYG{n}{temp}
            \PYG{c+c1}{\PYGZsh{} Normalization}
            \PYG{n}{w1}\PYG{o}{/=}\PYG{n}{la}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} the algorithm converge when the inner product of W(k+1)}
            \PYG{c+c1}{\PYGZsh{} and W(k) is close to 1. So we define lim as the absolute sum of the }
            \PYG{c+c1}{\PYGZsh{} inner product w1 and w and we subtract it from 1}
            \PYG{n}{lim} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{((}\PYG{n}{w1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{())}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{n}{w} \PYG{o}{=} \PYG{n}{w1} \PYG{p}{;} \PYG{n}{iterations}\PYG{o}{+=}\PYG{l+m+mi}{1}
        \PYG{n}{W}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,:]} \PYG{o}{=} \PYG{n}{w}
        \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{        The algorithm ends if one of below coditions is fullfilled}
\PYG{l+s+sd}{        i) The inner product of W(k+1) and W(K) is close to 1}
\PYG{l+s+sd}{        ii) If it surpasses the maximum number of iterations }
\PYG{l+s+sd}{        in the second , case the algorithm might not coverged }
\PYG{l+s+sd}{        \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{return} \PYG{n}{W}
\end{Verbatim}
